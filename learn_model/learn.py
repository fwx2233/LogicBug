"""
Learn APP's model
"""
import os
import json
import random
from collections import defaultdict
from appium import webdriver
from selenium.webdriver.common.by import By
from selenium.common import exceptions
import time
import socket
import subprocess, signal
import shutil

from learn_model import format_tools, packet_parser, get_ips
from log import mlog
from config import device_appium_config, button_constrain
from learn_model.my_check import check_if_frida_server_is_start

test_button_list = ['ADU1CWRD88:97:46:2C:9A:CE', 'SDU1CWRU2D88:97:46:2C:9A:CE', 'SAU1CWRU2', 'USU1CWRU2',
                    'RDU1CWRD88:97:46:2C:9A:CE', 'DCU1']
custom_order_dict = {
    'ADU1CWRD88:97:46:2C:9A:CE': 0,
    'RDU1CWRD88:97:46:2C:9A:CE': len(test_button_list) - 1
}


def random_list(button_list: list) -> list:
    """
    use <button_list> to generate a random list
    :param button_list: [button1, button2]
    :return: random list generated by <button_list>
    """
    shuffled_list = button_list.copy()
    random.shuffle(shuffled_list)
    return shuffled_list


def get_custom_click_list(custom_order: dict, button_list: list) -> list:
    """
    Incorporate a custom order into a randomly generated list.
    :param custom_order: {button1: order, button2: order}
    :param button_list: [button1, button2]
    :return: custom click order -> list
    """
    shuffled_list = random_list(button_list)
    custom_order = format_tools.sort_dict_by_value(custom_order)

    for item, order in custom_order.items():
        if order > len(shuffled_list) or order < (0 - len(shuffled_list)):
            mlog.log_func(mlog.ERROR, f"Custom order <{item}--{order}> out of range, please check your custom order.")
            exit(3)
        index = shuffled_list.index(item)
        shuffled_list.pop(index)
    for item, order in custom_order.items():
        if order >= 0:
            shuffled_list.insert(order, item)

    return shuffled_list


def generate_random_click_order_with_count(valuable_button_list: list, each_least_count=3, each_large_count=10):
    return_list = []
    for cur in valuable_button_list:
        cur_count = random.randint(each_least_count, each_large_count)
        return_list.extend([cur for i in range(cur_count)])
    return random_list(return_list)


class DeviceCls:
    def __init__(self, scan_folder_name, device_name, which_user, frida_flag=True):
        mlog.log_func(mlog.LOG, f"Current device: <{device_name}>, regarded as user: <{which_user}>")

        # paths
        self.ROOT_PATH = os.path.dirname(__file__)
        self.LOG_FOLDER_PATH = self.ROOT_PATH + "/../log/"
        self.PACKET_ROOT_PATH = self.ROOT_PATH + "/packets/"
        self.CONF_FOLDER_PATH = self.ROOT_PATH + "/../config/"
        self.SCRIPTS_FOLDER = self.ROOT_PATH + "/../scripts/"
        self.LEARNLIB_FOLDER = self.ROOT_PATH + "/learnlib_module/"
        self.ACT_TG_FILE = self.ROOT_PATH + "/../analyse_app/temp_scan_result/act_tg_" + scan_folder_name + ".json"
        self.ADD_TG_FILE = self.ROOT_PATH + "/../analyse_app/temp_scan_result/additional_tg_" + scan_folder_name + ".json"
        self.VALUABLE_BUTTON_FILE = self.CONF_FOLDER_PATH + "valuable_button.json"
        self.APPIUM_PATH = device_appium_config.appium_path

        # get config of device
        self.DEVICE_CONFIG_DICT = device_appium_config.get_device_config_by_name(device_name)
        if not self.DEVICE_CONFIG_DICT:
            mlog.log_func(mlog.ERROR, "Do not have device_name: " + device_name + ". Please check your input.")
            print("Device_name list: ", device_appium_config.get_device_list())
            exit(10)

        self.USER = which_user

        self.APK_NAME = self.DEVICE_CONFIG_DICT["appPackage"]
        self.APPIUM_IP = self.DEVICE_CONFIG_DICT["additionalMess"]["appium_ip"]
        self.APPIUM_PORT = self.DEVICE_CONFIG_DICT["additionalMess"]["port"]
        self.HOME_PAGE_ACT = self.DEVICE_CONFIG_DICT["additionalMess"]["homePage"]
        self.WIRELESS_CARD = self.DEVICE_CONFIG_DICT["additionalMess"]["wirelessCard"]
        self.APP_ACTIVITY = self.DEVICE_CONFIG_DICT["appActivity"]
        self.UDID = self.DEVICE_CONFIG_DICT["udid"]

        self.DEVICE_CONFIG_DICT_FOR_APPIUM = dict()
        # remove additional message
        for key in self.DEVICE_CONFIG_DICT:
            if key != "additionalMess":
                self.DEVICE_CONFIG_DICT_FOR_APPIUM[key] = self.DEVICE_CONFIG_DICT[key]

        # get valuable_buttion_dict
        self.val_but_dict = self.get_valuable_button(self.VALUABLE_BUTTON_FILE, self.USER)

        # modify wireless card message in script
        self.modify_mitm_script()


        # start appium for listen
        self.start_appium_server(self.APPIUM_PATH)
        time.sleep(2)

        if frida_flag:
            self.modify_frida_script()

        if frida_flag:
            self.start_frida_hook()
            time.sleep(10)

        # test flag and other info
        self.update_act_flag = False
        self.admin_password = "admin"
        self.cur_packet_name = ""
        self.cur_packet_folder = ""
        self.cur_packet_path = ""

    def get_valuable_button(self, button_conf_file, user) -> dict:
        with open(button_conf_file, "r") as f:
            valuable_button_click_path = json.load(f)

        if user not in valuable_button_click_path:
            mlog.log_func(mlog.ERROR, f"{user} is not in valuable_buttion.json")
            exit(-2)

        return valuable_button_click_path[user]

    def modify_mitm_script(self):
        mlog.log_func(mlog.LOG, "Modify mitm script")
        self.cur_key_log_file_path = self.PACKET_ROOT_PATH + 'sslkeylogfile.txt'

        # modify script
        lines = []
        with open(self.SCRIPTS_FOLDER + "launch_mitm.bash", "r") as f:
            for line in f.readlines():
                lines.append(line)
        # lines[1] = 'WIRELESS_CARD="' + self.WIRELESS_CARD + '"\n'
        lines[2] = 'KEY_LOG_FILE="' + self.PACKET_ROOT_PATH + 'sslkeylogfile.txt"\n'
        with open(self.SCRIPTS_FOLDER + "launch_mitm.bash", "w") as f:
            for line in lines:
                f.write(line)
        lines.clear()  # clear

        lines = []
        with open(self.SCRIPTS_FOLDER + "change_iptables.bash", "r") as f:
            for line in f.readlines():
                lines.append(line)
        lines[1] = 'WIRELESS_CARD="' + self.WIRELESS_CARD + '"\n'
        with open(self.SCRIPTS_FOLDER + "change_iptables.bash", "w") as f:
            for line in lines:
                f.write(line)

    def modify_frida_script(self):
        lines = []
        lines.append("#!/bin/bash")
        lines.append('target_app="' + self.APK_NAME + '"\n')
        lines.append('select_device="' + self.UDID + '"\n')
        lines.append('script_path="' + self.SCRIPTS_FOLDER + 'pinning_disable.js"\n')
        lines.append("frida -D $select_device -F $target_app -l $script_path")

        with open(self.SCRIPTS_FOLDER + "start_pinning_frida_script.bash", "w") as f:
            for line in lines:
                f.write(line)
        lines.clear()  # clear

    def start_tshark(self, pcapng_name):
        # admin_proc
        admin_proc = subprocess.Popen(["echo", self.admin_password], stdout=subprocess.PIPE)

        self.cur_packet_name = pcapng_name + '_' + str(int(time.time())) + ".pcapng"

        # create folder
        self.cur_packet_folder = self.PACKET_ROOT_PATH + self.cur_packet_name[:-7] + "/"
        if not os.path.exists(self.cur_packet_folder):
            os.makedirs(self.cur_packet_folder)

        self.cur_packet_path = self.cur_packet_folder + self.cur_packet_name
        # self.cur_packet_path = self.PACKET_ROOT_PATH + self.cur_packet_name

        # # kill mitm
        # self.kill_mitm()
        #
        # # change iptable rules
        # mlog.log_func(mlog.LOG, "Change iptable rules")
        # command = "sudo -S bash " + self.SCRIPTS_FOLDER + "change_iptables.bash"
        # change_iptables_proc = subprocess.Popen(command.split(), stdout=subprocess.PIPE)
        #
        # # start mitm
        # mlog.log_func(mlog.LOG, "launch mitm")
        # command = "bash " + self.SCRIPTS_FOLDER + "launch_mitm.bash"
        # # with open(self.LOG_FOLDER_PATH + "mitm_log.txt", "w") as log:
        # #     mitm_proc = subprocess.Popen(command.split(), stdout=log)
        # mitm_proc = subprocess.Popen(["bash", self.SCRIPTS_FOLDER+"launch_mitm.bash"], stdout=subprocess.PIPE)

        mlog.log_func(mlog.LOG, "Start capturing, save in file: " + self.PACKET_ROOT_PATH + self.cur_packet_name)
        # with open(self.LOG_FOLDER_PATH + "tshark_log_file.txt", "w") as log_file:
            # a = subprocess.Popen(["sudo", "-S", "tshark", "-i", self.WIRELESS_CARD, "-w", self.cur_packet_path], stdin=admin_proc.stdout, stdout=log_file)
        a = subprocess.Popen(["tshark", "-i", self.WIRELESS_CARD, "-w", self.cur_packet_path], stdout=open(self.LOG_FOLDER_PATH + "tshark_log_file.txt"))

        admin_proc.kill()

    def stop_tshark(self, with_error=0):
        admin_proc = subprocess.Popen(["echo", self.admin_password], stdout=subprocess.PIPE)
        # stop tshark and chmod
        self.kill_tshark()

        # # kill mitm
        # self.kill_mitm()

        # stop_proc = subprocess.Popen(["sudo", "-S", "chmod", "777", self.cur_packet_path],
        #                              stdin=admin_proc.stdout)
        # # chmod sslkeyfile
        # subprocess.check_call(["sudo", "-S", "chmod", "777", self.PACKET_ROOT_PATH + 'sslkeylogfile.txt'],
        #                       stdin=admin_proc.stdout)

        # self.chmod()

        # rename sslkeyfile
        os.rename(self.PACKET_ROOT_PATH + 'sslkeylogfile.txt',
                  self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[0] + ".txt")

        # move file to it's corresponding folder
        shutil.move(self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[0] + ".txt", self.cur_packet_folder)

        admin_proc.kill()

    def kill_mitm(self):
        mlog.log_func(mlog.LOG, "kill mitm and clear iptable rules")

        admin_proc = subprocess.Popen(["echo", self.admin_password], stdout=subprocess.PIPE)
        # get process id
        file_name = self.SCRIPTS_FOLDER + "1.txt"
        command = "sudo -S netstat -tunlp|grep 8080 > " + file_name
        # save_proc = subprocess.Popen(command.split(), stdin=admin_proc.stdout, stdout=subprocess.PIPE)
        os.system('echo %s | sudo -S %s' % (self.admin_password, command))

        # parse id and kill mitm process
        if os.path.exists(file_name):
            with open(file_name, "r") as f:
                lines = f.readlines()
                if lines:
                    process_id = lines[0].split()[-1].split("/")[0]
                    command = "sudo -S kill -9 " + process_id
                    # temp_proc = subprocess.Popen(command.split(), stdin=admin_proc.stdout)
                    os.system('echo %s | sudo -S %s' % (self.admin_password, command))
            os.remove(file_name)

        # clear iptables
        command = "sudo -S bash " + self.SCRIPTS_FOLDER + "clear_iptables.bash"
        os.system('echo %s | sudo -S %s' % (self.admin_password, command))

        admin_proc.kill()

    def kill_tshark(self):
        mlog.log_func(mlog.LOG, "kill tshark")

        fine_name = self.SCRIPTS_FOLDER + "temp_tshark_ps"
        command = "ps -aux|grep tshark > " + fine_name
        os.system(command)
        with open(fine_name, "r") as f:
            lines = f.readlines()
        if len(lines) > 1:
            admin_proc = subprocess.Popen(["echo", self.admin_password], stdout=subprocess.PIPE)
            for lin in lines[:-2]:
                porc_id = lin.split()[1]
                command = "sudo -S kill -9 " + porc_id
                temp_proc = subprocess.Popen(command.split(), stdin=admin_proc.stdout)
            admin_proc.kill()
        os.remove(fine_name)

    def start_frida_hook(self):
        mlog.log_func(mlog.LOG, "Start frida to ban the SSL Pinning")
        # start disable ssl pinning
        command = "bash " + self.SCRIPTS_FOLDER + "start_pinning_frida_script.bash"
        sslpin_process = subprocess.Popen(command.split(), stdout=subprocess.PIPE, stdin=open("/dev/null"))

    def stop_frida_hook(self):
        fine_name = self.SCRIPTS_FOLDER + "temp_tshark_ps"
        command = "ps -aux|grep frida > " + fine_name
        os.system(command)
        with open(fine_name, "r") as f:
            lines = f.readlines()
        if len(lines) > 1:
            admin_proc = subprocess.Popen(["echo", self.admin_password], stdout=subprocess.PIPE)
            for lin in lines[:-1]:
                porc_id = lin.split()[1]
                command = "sudo -S kill -9 " + porc_id
                temp = subprocess.Popen(command.split(), stdin=admin_proc.stdout)
            admin_proc.kill()
        os.remove(fine_name)

    def start_appium_server(self, path_to_appium):
        mlog.log_func(mlog.LOG, "Start appium service....")

        path = "/".join(path_to_appium.split("/")[:-1]) + ":"
        os.environ['PATH'] = path + os.environ['PATH']
        command = f"{path_to_appium} -a 127.0.0.1 -p {self.APPIUM_PORT} --session-override"
        with open(self.LOG_FOLDER_PATH + "appium_log.txt", "w") as log_file:
            process = subprocess.Popen(command, stdout=log_file, stderr=subprocess.STDOUT, shell=True,
                                       preexec_fn=os.setsid)
        self.appium_process = process

    def stop_appium_server(self):
        try:
            self.appium_process.terminate()
            time.sleep(1)
            os.killpg(os.getpgid(self.appium_process.pid), signal.SIGTERM)
        except ProcessLookupError:
            pass

    def get_tg_dict(self) -> dict:
        result = {}

        with open(self.ACT_TG_FILE, "r") as f:
            result.update(json.load(f))
        with open(self.ADD_TG_FILE, "r") as f:
            result.update(json.load(f))

        return result

    def parse_packet_and_get_response(self, database, packet_name, op_name, start_time, end_time) -> str:
        return packet_parser.get_new_op_class_for_response(database, packet_name, self.cur_key_log_file_path, op_name,
                                                           start_time, end_time)

    def start_driver(self):
        """
        read config of device and start appium driver
        :return: device driver for auto click
        """
        mlog.log_func(mlog.LOG, "Get device config:")
        mlog.log_dict_func(mlog.LOG, self.DEVICE_CONFIG_DICT_FOR_APPIUM)

        driver = webdriver.Remote(self.APPIUM_IP, self.DEVICE_CONFIG_DICT_FOR_APPIUM)

        self.driver = driver

    def start_driver_and_init(self):
        self.start_driver()
        self.back_to_home()

    def stop_driver(self):
        mlog.log_func(mlog.LOG, "Stop driver")
        self.driver.quit()
        self.stop_appium_server()

    def stop_learn(self):
        mlog.log_func(mlog.LOG, "Stop capture.")
        # stop packet capture, close android driver
        self.stop_tshark()
        self.stop_frida_hook()

    def back_to_home(self):
        mlog.log_func(mlog.LOG, "Back to homepage")
        command = f"adb -s {self.UDID} shell am start -n {self.APK_NAME}/{self.APP_ACTIVITY}"
        while self.APK_NAME + self.driver.current_activity != self.HOME_PAGE_ACT:
            os.system(command)
            time.sleep(0.5)

        # back to home page
        while not self.click_button("BackHome"):
            mlog.log_func(mlog.LOG, "Press back-system")
            self.driver.back()
            time.sleep(0.5)

    def click_and_save(self, ui_name, waiting_time=3):
        """
        Click the button
        :param ui_name: action name
        :param waiting_time:
        :return:
        """
        mlog.log_func(mlog.LOG, f"<{self.USER}> Click task-----{ui_name}")
        start_time = time.time()
        if self.click_button(ui_name):
            time.sleep(waiting_time)
            end_time = time.time()
            # save log
            action_log_file = self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[
                0] + "/" + ui_name + "/" + ui_name + '_' + str(int(start_time)) + ".txt"
            if not os.path.exists(self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[0] + "/" + ui_name + "/"):
                os.makedirs(self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[0] + "/" + ui_name + "/")
            with open(action_log_file, "w") as log:
                log.write(self.cur_packet_name)
                log.write('\n')
                log.write(str(start_time))
                log.write('\n')
                log.write(str(end_time))
            get_ips.get_and_save_ip_list_by_apk(self.APK_NAME, self.UDID)
            return [start_time, end_time]
        return False

    def click_button(self, ui_name):
        """
        Click the button
        :param ui_name: action name will be clicked
        """
        is_special_op = False
        if ui_name in self.val_but_dict["Special"]:
            is_special_op = True
        elif ui_name not in self.val_but_dict.keys():
            mlog.log_func(mlog.ERROR, f"UI <{ui_name}> which will be clicked is not in config/valuable_button.json")
            return False

        # get click path
        if not is_special_op:
            click_path_dict = self.val_but_dict[ui_name]
        else:
            click_path_dict = self.val_but_dict["Special"][ui_name]

        # click one by one
        for index in click_path_dict.keys():
            # waiting
            if "waiting_time" in click_path_dict[index].keys():
                time.sleep(click_path_dict[index]["waiting_time"])

            if "description" in click_path_dict[index].keys():
                mlog.log_func(mlog.LOG, index + "---" + click_path_dict[index]["description"], t_count=1)
            else:
                mlog.log_func(mlog.LOG, index + "---" + ui_name + ": " + click_path_dict[index], t_count=1)

            # get location and click
            if "xpath" in click_path_dict[index].keys():
                cur_ui_xpath = click_path_dict[index]["xpath"]

                # if exist
                try:
                    # click
                    target = self.driver.find_element(By.XPATH, cur_ui_xpath)
                    if self.update_act_flag:
                        click_path_dict[index]["act_before"] = self.driver.current_activity
                    target.click()
                    if self.update_act_flag:
                        click_path_dict[index]["act_after"] = self.driver.current_activity
                except exceptions.NoSuchElementException:
                    # retry for 3 times
                    if_find_flag = False
                    for temp_index in range(3):
                        time.sleep(2)
                        try:
                            self.driver.find_element(By.XPATH, cur_ui_xpath).click()
                            if_find_flag = True
                            break
                        except exceptions.NoSuchElementException:
                            pass
                    if not if_find_flag:
                        mlog.log_func(mlog.LOG,
                                      "can not find component when --- " + click_path_dict[index]["description"])
                        return False

            # find element by resource id
            elif "resource_id" in click_path_dict[index].keys():
                cur_ui_id = click_path_dict[index]["resource_id"]
                id_index = click_path_dict[index]["rec_index"]
                act_before = click_path_dict[index]["act_before"]
                act_after = click_path_dict[index]["act_after"]

                # click with resource_id
                try:
                    target = self.driver.find_element(By.ID, cur_ui_id)
                    if self.update_act_flag:
                        click_path_dict[index]["act_before"] = self.driver.current_activity
                    target.click()
                    if self.update_act_flag:
                        click_path_dict[index]["act_after"] = self.driver.current_activity
                except exceptions.NoSuchElementException:
                    # retry for 3 times
                    if_find_flag = False
                    for temp_index in range(3):
                        time.sleep(2)
                        try:
                            self.driver.find_element(By.ID, cur_ui_id).click()
                            if_find_flag = True
                            break
                        except exceptions.NoSuchElementException:
                            pass
                    if not if_find_flag:
                        mlog.log_func(mlog.LOG,
                                      "can not find component when --- " + click_path_dict[index]["description"])
                        return False
            elif "posi_x" in click_path_dict[index].keys() and "posi_y" in click_path_dict[index].keys():
                self.driver.tap([(click_path_dict[index]["posi_x"], click_path_dict[index]["posi_y"])])

            # get current activity and check
            time.sleep(0.5)  # wait for activity
            cur_activity = self.driver.current_activity

        return True

    def randomly_create_database(self, valuable_button_list, mean_size=8):
        def check_if_enough():
            total_count = 0
            count_dict = defaultdict(int)
            for op_name in valuable_button_list:
                if op_name in os.listdir(self.cur_packet_path):
                    op_folder = self.cur_packet_path + op_name + "/"
                    count_dict[op_name] += len(
                        [x for x in os.listdir(op_folder) if op_name in x and x.split(".")[-1] == "txt"])
                    total_count += count_dict[op_name]
                else:
                    count_dict[op_name] += 0
            if 0 in list(count_dict.values()) or total_count < len(valuable_button_list) * mean_size:
                return False
            return True

        # round 1
        ori_click_order = generate_random_click_order_with_count(valuable_button_list)
        for op in ori_click_order:
            self.back_to_home()
            self.click_and_save(op)

        while not check_if_enough():
            ori_click_order = generate_random_click_order_with_count(valuable_button_list)
            for op in ori_click_order:
                self.back_to_home()
                self.click_and_save(op)


class LearnCls:
    def __init__(self):
        # paths
        self.ROOT_PATH = os.path.dirname(__file__)
        self.CONF_FOLDER_PATH = self.ROOT_PATH + "/../config/"
        self.LEARNLIB_FOLDER = self.ROOT_PATH + "/learnlib_module/"
        self.VALUABLE_BUTTON_FILE = self.CONF_FOLDER_PATH + "valuable_button.json"

        # communication information
        self.LOCAL_IP = ""
        self.LOCAL_PORT = 7011
        self.SERVER_IP = "127.0.0.1"
        self.SERVER_PORT = 9999
        self.SOCKET = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.SYSTEM_MESSAGE = 0
        self.LEARNLIB_MESSAGE = 1
        self.QUERY_MESSAGE = 2

    def load_alphabet(self, overlook_button_list: list):
        """
        Send a reply to learner to tell the scan results.
        :param overlook_button_list: ["user1|AS"]
        :return: response from Learner
        """
        # print log
        mlog.log_func(mlog.LOG, "send input_bat to learner...")

        # load valuable button dictionary
        with open(self.VALUABLE_BUTTON_FILE, "r") as val_but_file:
            but_dict = json.load(val_but_file)

        # load ui_list
        ui_list = []
        for user, button_dict in but_dict.items():
            button_name_list = list(button_dict.keys())
            for item in button_name_list:
                if item != "Special" and (user + "|" + item) not in overlook_button_list:
                    ui_list.append(user + "|" + item)

        mlog.log_list_func(mlog.LOG, ui_list)

        # communicate with the server
        message = self.SOCKET.recv(1024)
        message_type = message[0]
        context = message[1:].decode('utf-8')
        if message_type == self.SYSTEM_MESSAGE and context == "alphabet":
            mlog.log_func(mlog.LOG, "Receive alphabet send request")

            # create file for alphabet
            alphabet_file = self.LEARNLIB_FOLDER + "src/main/resources/input_bat"
            with open(alphabet_file, "w") as f:
                for item in ui_list:
                    if item != ui_list[-1]:
                        f.write(item + "\n")
                    else:
                        f.write(item)
            mlog.log_func(mlog.LOG, "Create the alphabet file input_bat")

            # Send reply message
            reply_context = "Succeed!"
            reply_message = bytes([self.SYSTEM_MESSAGE]) + reply_context.encode('utf-8')
            self.SOCKET.sendall(reply_message)
            mlog.log_func(mlog.LOG, "Send alphabet success")
        else:
            mlog.log_func(mlog.ERROR, "Don't receive alphabet send request")

    def create_socket(self):
        mlog.log_func(mlog.LOG, "Start connecting to server...")
        self.SOCKET.bind((self.LOCAL_IP, self.LOCAL_PORT))
        self.SOCKET.connect((self.SERVER_IP, self.SERVER_PORT))
        mlog.log_func(mlog.LOG, "Connection build")

    def close_socket(self):
        mlog.log_func(mlog.LOG, "Close the socket...")
        self.SOCKET.close()

    def response_to_learner(self, output):
        """
        Tell the learner the output of operation.
        :param output: result str from packet parsing
        """
        reply_message = bytes([1]) + output.encode('utf-8')
        mlog.log_func(mlog.LOG, "Send reply message: " + output)
        self.SOCKET.sendall(reply_message)

    def get_input_from_learner(self):
        # communicate with the server
        message = self.SOCKET.recv(1024)
        if message:
            message_type = message[0]
            context = message[1:].decode('utf-8')
            if message_type == self.SYSTEM_MESSAGE:
                mlog.log_func(mlog.LOG, "Receive system message: " + context)
                return context
            elif message_type == self.LEARNLIB_MESSAGE:
                mlog.log_func(mlog.LOG, "Receive learnlib message: " + context)
                return context
            elif message_type == self.QUERY_MESSAGE:
                mlog.log_func(mlog.LOG, "Receive query message: " + context)
                return context
            else:
                mlog.log_func(mlog.ERROR, "Don't receive input message")

            return context
        else:
            return "closeConnect"


def read_log_and_gen_response_list(log_file_path):
    if not os.path.exists(log_file_path):
        return None

    return_list = []

    # read file
    with open(log_file_path, "r") as log_file_handle:
        lines = log_file_handle.readlines()

        last_reset_index = -1
        req_resp_tuple = ["", ""]
        for line in lines:
            if "Receive learnlib message" in line:
                req_resp_tuple[0] = line.split()[-1].replace("\n", "")
                if req_resp_tuple[0] == "Reset":
                    last_reset_index = len(return_list)
            elif "Receive query message" in line:
                req_resp_tuple[0] = line.split()[-1].replace("\n", "")
            elif "Send reply message" in line:
                req_resp_tuple[1] = line.split()[-1].replace("\n", "")
                if req_resp_tuple[0] != "":
                    return_list.append(req_resp_tuple)
                else:
                    mlog.log_func(mlog.ERROR, "Extracting log failed, please check operation order")
                    mlog.log_func(mlog.ERROR, "Start learning without help from log...")
                    return None
                req_resp_tuple = ["", ""]
            else:
                continue

    return return_list[:last_reset_index]

# def auto_learn_to_create_dataset(scan_result_name):
#     # create an entity of learn
#     learn_entity = DeviceCls(scan_result_name, "nexus")
#     # get val_buttons
#     val_but_dict = get_valuable_button(learn_entity.VALUABLE_BUTTON_FILE)
#     val_but_list = list(val_but_dict.keys())
#     val_but_list.remove("Special")
#     val_but_list.remove("add_scene")
#
#     # start app and get driver
#     learn_entity.start_driver()
#
#     learn_entity.start_tshark("random_click_dataset")
#
#     # click and capture
#     learn_entity.randomly_create_database(val_but_list, val_but_dict)
#
#     mlog.log_func(mlog.LOG, "Stop capture.")
#     # stop packet capture, close android driver
#     learn_entity.stop_tshark()
#     learn_entity.stop_frida_hook()
#     learn_entity.stop_driver()


def manual_learn_to_create_dataset(scan_result_name, database):
    mlog.log_func(mlog.LOG, "Manual test start")

    # create an entity of learn and start driver
    pixel_entity = DeviceCls(scan_result_name, "pixel7", "user1", frida_flag=True)
    pixel_entity.start_driver_and_init()
    nexus_entity = DeviceCls(scan_result_name, "nexus", "user2", frida_flag=False)
    nexus_entity.start_driver_and_init()

    # start tshark
    pixel_entity.start_tshark("manual_dataset")

    test_order_list = ["SAU1CWRU2", "DCU1", "USU1CWRU2", "ADU1CWR", "DCU1", "SAU1CWRU2", "DCU1", "USU1CWRU2", "RDU1CWR",
                       "ADU1CWR", "RDU1CWR"]
    # test_order_list = ["SAU1CWRU2"]
    mlog.log_func(mlog.LOG, "test order")
    mlog.log_list_func(mlog.LOG, test_order_list)

    for count in range(2):
        for cur_op_name in test_order_list:
            pixel_entity.back_to_home()
            time_list = pixel_entity.click_and_save(cur_op_name, waiting_time=3)

            if time_list:
                mlog.log_func(mlog.LOG, pixel_entity.parse_packet_and_get_response(database, pixel_entity.cur_packet_name,
                                                       cur_op_name, time_list[0], time_list[1]))
            else:
                # can not tap
                mlog.log_func(mlog.ERROR, f"Option: {cur_op_name} can't tap")
                mlog.log_func(mlog.LOG, "NoElement")

            if cur_op_name == "SAU1CWRU2":
                mlog.log_func(mlog.DEBUG, "Current operation is <SA>, waiting for user2 agree")
                nexus_entity.back_to_home()
                nexus_entity.click_button("AcceptInvite")

    # back to homepage
    pixel_entity.back_to_home()
    nexus_entity.back_to_home()

    # stop packet capture, close android driver
    pixel_entity.stop_learn()

    # stop driver
    pixel_entity.stop_driver()
    nexus_entity.stop_driver()


def learn_model_main(scan_result_name, database, learn_dir_name="learnlib_learn", use_log_file_to_reponse=False, log_file_path=""):
    """
    main function: use scan_result_name from databse to get request from learnlib and response
    :param scan_result_name:
    :param dataset:
    :param device:
    """
    mlog.log_func(mlog.LOG, "Learn model start")

    # create an entity for learning
    learn_entity = LearnCls()
    # create sockets to connect to learners for communication
    learn_entity.create_socket()
    # pass the alphabet to the learner
    overlook_list = ["user1|AS", "user1|SDU1CWR", "user1|VD1S", #"user1|ADU1CWR", "user1|RDU1CWR", "user1|DCU1",
                     "user2|AcceptDeviceShare", "user2|RejectDeviceShare", "user2|AcceptInvite", "user2|DenyInvite"]
    learn_entity.load_alphabet(overlook_list)

    # create device entity for click
    pixel7_entity = DeviceCls(scan_result_name, "pixel7", "user1", frida_flag=True)
    pixel7_entity.start_driver_and_init()
    nexus_entity = DeviceCls(scan_result_name, "nexus", "user2", frida_flag=False)
    nexus_entity.start_driver_and_init()

    # for index
    user_device_entity_dict = {
        "user1": pixel7_entity,
        "user2": nexus_entity
    }

    # # start tshark
    pixel7_entity.start_tshark(learn_dir_name)
    time.sleep(5)

    if use_log_file_to_reponse:
        operation_result_list = read_log_and_gen_response_list(log_file_path)
        while operation_result_list:
            cur_op_result = operation_result_list.pop(0)
            option = learn_entity.get_input_from_learner()
            if option == cur_op_result[0]:
                learn_entity.response_to_learner(cur_op_result[1])
            else:
                """
                    need modify---modify log to the last correct reset operation and restart
                """
                mlog.log_func(mlog.ERROR,
                              f"Op from log: <{cur_op_result[0]}>, but receive: <{option}>\n\tPlease check log or not use log file")
                # stop packet capture, close android driver
                # pixel7_entity.stop_learn()
                #
                # # stop driver
                # pixel7_entity.stop_driver()
                # nexus_entity.stop_driver()
                learn_entity.close_socket()
                exit(-4)

    # get constrain dictionary
    mlog.log_func(mlog.LOG, "Get constrain rules")
    mlog.log_dict_func(mlog.LOG, button_constrain.constrain_dict)
    mlog.log_dict_func(mlog.LOG, button_constrain.conflict_dic)

    # A stack, store current cache
    run_cache = []

    # learning
    while True:
        option = learn_entity.get_input_from_learner()

        if option == "closeConnect":
            mlog.log_func(mlog.LOG, "Stop learning...")
            learn_entity.response_to_learner("close the client")
            learn_entity.close_socket()
            break

        if option == "checkCounterExample":
            mlog.log_func(mlog.LOG, "Check the counter example...")
            learn_entity.response_to_learner("WaitForChecking")
            continue

        if option == "Reset":
            mlog.log_func(mlog.LOG, "Reset--USU1CWRU2")
            user_device_entity_dict["user1"].back_to_home()
            user_device_entity_dict["user1"].click_button("USU1CWRU2")
            mlog.log_func(mlog.LOG, "Reset--VD1S")
            user_device_entity_dict["user1"].back_to_home()
            user_device_entity_dict["user1"].click_button("VD1S")
            mlog.log_func(mlog.LOG, "Reset--RDU1CWR")
            user_device_entity_dict["user1"].back_to_home()
            user_device_entity_dict["user1"].click_button("RDU1CWR")

            mlog.log_func(mlog.LOG, "Reset--DenyInvite")
            user_device_entity_dict["user2"].back_to_home()
            user_device_entity_dict["user2"].click_button("DenyInvite")

            # clear cache
            run_cache.clear()
            """
            how to check?
            """

            learn_entity.response_to_learner("Reset_suc")
            continue

        # check if current option is in constrain list
        if option in button_constrain.constrain_dict and button_constrain.constrain_dict[option] not in run_cache:
            # can not tap
            mlog.log_func(mlog.LOG, f"Option: {option} can't tap --- by cache")
            mlog.log_func(mlog.LOG, f"Current cache: ")
            mlog.log_list_func(mlog.LOG, run_cache)
            learn_entity.response_to_learner("NoElement")
            continue

        if option in button_constrain.conflict_dic and button_constrain.conflict_dic[option] in run_cache:
            run_cache.remove(button_constrain.conflict_dic[option])

        if option in button_constrain.conflict_dic.values() and option not in run_cache:
            run_cache.append(option)

        print("run_cache: ", run_cache)

        user = option.split("|")[0]
        option = option.split("|")[-1]

        user_device_entity_dict[user].back_to_home()
        time_list = user_device_entity_dict[user].click_and_save(option, waiting_time=3)

        if time_list:
            class_result = user_device_entity_dict[user].parse_packet_and_get_response(database,
                                                                                       user_device_entity_dict[
                                                                                           user].cur_packet_name,
                                                                                       option, time_list[0],
                                                                                       time_list[1])
            # mlog.log_func(mlog.LOG, class_result)
            if class_result:
                learn_entity.response_to_learner(class_result)
            else:
                break

            if option == "SAU1CWRU2":
                mlog.log_func(mlog.DEBUG, "Current operation is <SA>, waiting for user2 agree")
                user_device_entity_dict["user2"].back_to_home()
                user_device_entity_dict["user2"].click_button("AcceptInvite")
        else:
            # can not tap
            mlog.log_func(mlog.LOG, f"Option: {option} can't tap")

            # check if device is offline
            if option == "ADU1CWR" and "user1|ADU1CWR" not in run_cache:
                # device offline
                mlog.log_func(mlog.ERROR, "Device Offline, please check")
            learn_entity.response_to_learner("NoElement")
            break

    # learn stop, back to home
    pixel7_entity.back_to_home()
    nexus_entity.back_to_home()

    # stop packet capture, close android driver
    pixel7_entity.stop_learn()

    # stop driver
    pixel7_entity.stop_driver()
    nexus_entity.stop_driver()


if __name__ == "__main__":
    mlog.clear_log()
    # if not check_if_frida_server_is_start():
    #     print("[frida server] is not start")
    #     exit(10)
    # manual_learn_to_create_dataset("20230920183445_com.huawei.smarthome", "manual_dataset_1709359674")
    learn_model_main("20230920183445_com.huawei.smarthome", "manual_dataset_1709359674", use_log_file_to_reponse=False, log_file_path=os.path.dirname(__file__) + "/../log/program_save.log")
