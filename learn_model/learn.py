"""
Learn APP's model
"""
import os
import json
import random
import time
import socket

from learn_model.device import DeviceCls
from learn_model.mitm_network import MitmCLs
from learn_model import format_tools
from log import mlog
from config import button_constrain


def random_list(button_list: list) -> list:
    """
    use <button_list> to generate a random list
    :param button_list: [button1, button2]
    :return: random list generated by <button_list>
    """
    shuffled_list = button_list.copy()
    random.shuffle(shuffled_list)
    return shuffled_list


def get_custom_click_list(custom_order: dict, button_list: list) -> list:
    """
    Incorporate a custom order into a randomly generated list.
    :param custom_order: {button1: order, button2: order}
    :param button_list: [button1, button2]
    :return: custom click order -> list
    """
    shuffled_list = random_list(button_list)
    custom_order = format_tools.sort_dict_by_value(custom_order)

    for item, order in custom_order.items():
        if order > len(shuffled_list) or order < (0 - len(shuffled_list)):
            mlog.log_func(mlog.ERROR, f"Custom order <{item}--{order}> out of range, please check your custom order.")
            exit(3)
        index = shuffled_list.index(item)
        shuffled_list.pop(index)
    for item, order in custom_order.items():
        if order >= 0:
            shuffled_list.insert(order, item)

    return shuffled_list


def generate_random_click_order_with_count(valuable_button_list: list, each_least_count=3, each_large_count=10):
    return_list = []
    for cur in valuable_button_list:
        cur_count = random.randint(each_least_count, each_large_count)
        return_list.extend([cur for i in range(cur_count)])
    return random_list(return_list)


class LearnCls:
    def __init__(self):
        # paths
        self.ROOT_PATH = os.path.dirname(__file__)
        self.CONF_FOLDER_PATH = self.ROOT_PATH + "/../config/"
        self.LEARNLIB_FOLDER = self.ROOT_PATH + "/learnlib_module/"
        self.VALUABLE_BUTTON_FILE = self.CONF_FOLDER_PATH + "valuable_button.json"

        # communication information
        self.LOCAL_IP = ""
        self.LOCAL_PORT = 7011
        self.SERVER_IP = "127.0.0.1"
        self.SERVER_PORT = 9999
        self.SOCKET = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.SYSTEM_MESSAGE = 0
        self.LEARNLIB_MESSAGE = 1
        self.QUERY_MESSAGE = 2

    def load_alphabet(self, overlook_button_list: list):
        """
        Send a reply to learner to tell the scan results.
        :param overlook_button_list: ["user1|AS"]
        :return: response from Learner
        """
        # print log
        mlog.log_func(mlog.LOG, "send input_bat to learner...")

        # load valuable button dictionary
        with open(self.VALUABLE_BUTTON_FILE, "r") as val_but_file:
            but_dict = json.load(val_but_file)

        # load ui_list
        ui_list = []
        for user, button_dict in but_dict.items():
            button_name_list = list(button_dict.keys())
            for item in button_name_list:
                if item != "Special" and (user + "|" + item) not in overlook_button_list:
                    ui_list.append(user + "|" + item)

        mlog.log_list_func(mlog.LOG, ui_list)

        # communicate with the server
        message = self.SOCKET.recv(1024)
        message_type = message[0]
        context = message[1:].decode('utf-8')
        if message_type == self.SYSTEM_MESSAGE and context == "alphabet":
            mlog.log_func(mlog.LOG, "Receive alphabet send request")

            # create file for alphabet
            alphabet_file = self.LEARNLIB_FOLDER + "src/main/resources/input_bat"
            with open(alphabet_file, "w") as f:
                for item in ui_list:
                    if item != ui_list[-1]:
                        f.write(item + "\n")
                    else:
                        f.write(item)
            mlog.log_func(mlog.LOG, "Create the alphabet file input_bat")

            # Send reply message
            reply_context = "Succeed!"
            reply_message = bytes([self.SYSTEM_MESSAGE]) + reply_context.encode('utf-8')
            self.SOCKET.sendall(reply_message)
            mlog.log_func(mlog.LOG, "Send alphabet success")
        else:
            mlog.log_func(mlog.ERROR, "Don't receive alphabet send request")

    def create_socket(self):
        mlog.log_func(mlog.LOG, "Start connecting to server...")
        self.SOCKET.bind((self.LOCAL_IP, self.LOCAL_PORT))
        self.SOCKET.connect((self.SERVER_IP, self.SERVER_PORT))
        mlog.log_func(mlog.LOG, "Connection build")

    def close_socket(self):
        mlog.log_func(mlog.LOG, "Close the socket...")
        self.SOCKET.close()

    def response_to_learner(self, output):
        """
        Tell the learner the output of operation.
        :param output: result str from packet parsing
        """
        reply_message = bytes([1]) + output.encode('utf-8')
        mlog.log_func(mlog.LOG, "Send reply message: " + output)
        self.SOCKET.sendall(reply_message)

    def get_input_from_learner(self):
        # communicate with the server
        message = self.SOCKET.recv(1024)
        if message:
            message_type = message[0]
            context = message[1:].decode('utf-8')
            if message_type == self.SYSTEM_MESSAGE:
                mlog.log_func(mlog.LOG, "Receive system message: " + context)
                return context
            elif message_type == self.LEARNLIB_MESSAGE:
                mlog.log_func(mlog.LOG, "Receive learnlib message: " + context)
                return context
            elif message_type == self.QUERY_MESSAGE:
                mlog.log_func(mlog.LOG, "Receive query message: " + context)
                return context
            else:
                mlog.log_func(mlog.ERROR, "Don't receive input message")

            return context
        else:
            return "closeConnect"


# def auto_learn_to_create_dataset(scan_result_name):
#     # create an entity of learn
#     learn_entity = DeviceCls(scan_result_name, "nexus")
#     # get val_buttons
#     val_but_dict = get_valuable_button(learn_entity.VALUABLE_BUTTON_FILE)
#     val_but_list = list(val_but_dict.keys())
#     val_but_list.remove("Special")
#     val_but_list.remove("add_scene")
#
#     # start app and get driver
#     learn_entity.start_driver()
#
#     learn_entity.start_tshark("random_click_dataset")
#
#     # click and capture
#     learn_entity.randomly_create_database(val_but_list, val_but_dict)
#
#     mlog.log_func(mlog.LOG, "Stop capture.")
#     # stop packet capture, close android driver
#     learn_entity.stop_tshark()
#     learn_entity.stop_frida_hook()
#     learn_entity.stop_driver()


def learn_model_main(scan_result_name, database, learn_dir_name="learnlib_learn"):
    """
    main function: use scan_result_name from databse to get request from learnlib and response
    :param scan_result_name:
    :param dataset:
    :param device:
    """
    mlog.log_func(mlog.LOG, "Learn model start")

    # create an entity for learning
    learn_entity = LearnCls()
    # create sockets to connect to learners for communication
    learn_entity.create_socket()
    # pass the alphabet to the learner
    overlook_list = ["user1|AS", "user1|SDU1CWR", "user1|VD1S", #"user1|ADU1CWR", "user1|RDU1CWR", "user1|DCU1",
                     "user2|AcceptDeviceShare", "user2|RejectDeviceShare", "user2|AcceptInvite", "user2|DenyInvite"]
    reset_op_list = ["user1|USU1CWRU2", "user1|VD1S", "user1|RDU1CWR", "user2|DenyInvite"]
    learn_entity.load_alphabet(overlook_list)

    pro_end_flag = False

    while not pro_end_flag:
        # create device entity for click
        pixel7_entity = DeviceCls(scan_result_name, "pixel7", "user1", frida_flag=True)
        pixel7_entity.start_driver_and_init()
        nexus_entity = DeviceCls(scan_result_name, "nexus", "user2", frida_flag=False)
        nexus_entity.start_driver_and_init()

        # for index
        user_device_entity_dict = {
            "user1": pixel7_entity,
            "user2": nexus_entity
        }

        # # start tshark
        pixel7_entity.start_tshark(learn_dir_name)
        time.sleep(5)

        # get constrain dictionary
        mlog.log_func(mlog.LOG, "Get button constrain rules")
        mlog.log_dict_func(mlog.LOG, button_constrain.constrain_dict)
        mlog.log_dict_func(mlog.LOG, button_constrain.conflict_dic)

        # A stack, store current cache
        run_cache = []

        # learning
        while True:
            try:
                option = learn_entity.get_input_from_learner()

                if option == "closeConnect":
                    mlog.log_func(mlog.LOG, "Learning program is finish, stop learning...")
                    learn_entity.response_to_learner("close the client")
                    learn_entity.close_socket()
                    pro_end_flag = True
                    break

                if option == "checkCounterExample":
                    mlog.log_func(mlog.LOG, "Check the counter example...")
                    learn_entity.response_to_learner("WaitForChecking")
                    continue

                if option == "Reset":
                    for reset_option in reset_op_list:
                        mlog.log_func(mlog.LOG, f"Reset--{reset_option}")
                        user = reset_option.split("|")[0]
                        cur_reset_option = reset_option.split("|")[-1]

                        # back to home
                        if not user_device_entity_dict[user].back_to_home():
                            break
                        user_device_entity_dict[user].click_button(cur_reset_option)

                    # clear cache
                    run_cache.clear()
                    """
                    how to check reset success?
                    """
                    learn_entity.response_to_learner("Reset_suc")
                    continue

                # check if current option is in constrain list
                if option in button_constrain.constrain_dict and button_constrain.constrain_dict[option] not in run_cache:
                    # can not tap
                    mlog.log_func(mlog.LOG, f"Option: {option} can't tap --- by cache")
                    mlog.log_func(mlog.LOG, f"Current cache: ")
                    mlog.log_list_func(mlog.LOG, run_cache)
                    learn_entity.response_to_learner("NoElement")
                    continue

                # update cache
                if option in button_constrain.conflict_dic and button_constrain.conflict_dic[option] in run_cache:
                    run_cache.remove(button_constrain.conflict_dic[option])
                if option in button_constrain.conflict_dic.values() and option not in run_cache:
                    run_cache.append(option)

                mlog.log_func(mlog.DEBUG, f"After add, run_cache: {run_cache}")

                user = option.split("|")[0]
                option = option.split("|")[-1]

                if not user_device_entity_dict[user].back_to_home():
                    break

                # click and response
                time_list = user_device_entity_dict[user].click_and_save(option, waiting_time=3)
                if time_list:
                    class_result = user_device_entity_dict[user].parse_packet_and_get_response(database,
                                                                                               user_device_entity_dict[
                                                                                                   user].cur_packet_name,
                                                                                               option, time_list[0],
                                                                                               time_list[1])
                    if class_result:
                        learn_entity.response_to_learner(class_result)
                    else:
                        mlog.log_func(mlog.ERROR, f"Option <{option}> No classify result, can not response to learner")
                        pro_end_flag = True
                        break

                    if option == "SAU1CWRU2" and time_list:
                        mlog.log_func(mlog.DEBUG, "Current operation is <SA>, waiting for user2 agree")
                        if not user_device_entity_dict["user2"].back_to_home():
                            break
                        user_device_entity_dict["user2"].click_button("AcceptInvite")
                else:
                    # can not tap
                    mlog.log_func(mlog.LOG, f"Option: {option} can't tap")
                    learn_entity.response_to_learner("NoElement")

                    # check if device is offline
                    if option == "ADU1CWR" and "user1|ADU1CWR" not in run_cache:
                        # device offline
                        mlog.log_func(mlog.ERROR, "Device Offline, please check")
                        pro_end_flag = True
                        break

            except BrokenPipeError:
                mlog.log_func(mlog.ERROR, "Server has broken, quit")
                pro_end_flag = True
                break

        # stop packet capture, close android driver
        pixel7_entity.stop_learn()

        # stop driver
        pixel7_entity.stop_driver()
        nexus_entity.stop_driver()

        if not pro_end_flag:
            learn_entity.response_to_learner("RestartLearning")

    learn_entity.close_socket()
    mlog.log_func(mlog.LOG, "Learn finish")


def manual_create_database_for_double_wifi(scan_result_name, database_name="double_wifi_dataset"):
    mlog.log_func(mlog.LOG, "Manual test start")

    # init mitm entity
    local_mitm_entity = MitmCLs("local")
    remote_mitm_entity = MitmCLs("remote")
    mitm_entity_list = [
        local_mitm_entity,
        remote_mitm_entity
    ]

    # start mitm
    start_count = 0
    for entity in mitm_entity_list:
        entity.start_mitm_main(not start_count)
        start_count += 1

    # save distance and pcap file name
    distance_capture_dict = {}

    # start tshark -- capture
    for entity in mitm_entity_list:
        capture_file_name = entity.start_tshark(f"{database_name}")
        # set name
        distance_capture_dict[entity.distance] = capture_file_name

    time.sleep(5)

    # set phone config
    phone_entity_dict = {
        "user1": {
            "local": "pixel7",
            "remote": "pixel6-1"
        },
        "user2": {
            "local": "nexus",
            "remote": "pixel6-2"
        }
    }
    # create phone entity for each
    for user in phone_entity_dict:
        for distance in phone_entity_dict[user]:
            phone_name = phone_entity_dict[user][distance]
            # create entity and init
            phone_entity = DeviceCls(scan_result_name, phone_name, user, distance, frida_flag=True)
            phone_entity.start_driver_and_init()
            # set pcap file name
            phone_entity.set_packet_name(distance_capture_dict[distance])
            # save handle
            phone_entity_dict[user][distance] = phone_entity

    test_order_list = ["user1|local|InviteToHome", "user2|remote|AcceptInvite", "user1|local|RemoveFromHome",
                       "user1|local|AddDevice", "user1|local|DeviceControl", "user1|local|InviteToHome", "user1|remote|DeviceControl", "user2|remote|AcceptInvite",
                       "user2|local|DeviceControl", "user1|remote|DeviceControl", "user2|remote|DeviceControl"
                       "user1|local|RemoveDevice", "user1|local|InviteToHome", "user1|local|AddDevice",
                       "user1|local|RemoveFromHome", "user1|local|RemoveDevice",
                       "user1|local|InviteToHome", "user2|remote|DenyInvite"]

    mlog.log_func(mlog.LOG, "Test click order")
    mlog.log_list_func(mlog.LOG, test_order_list)

    error_flag = False
    for count in range(3):
        if error_flag:
            break
        # test count
        for operation_full_name in test_order_list:
            cur_user = operation_full_name.split("|")[0]
            cur_distance = operation_full_name.split("|")[1]

            # back to home
            if not phone_entity_dict[cur_user][cur_distance].back_to_home():
                error_flag = True
                break

            # refresh
            phone_entity_dict[cur_user][cur_distance].pull_to_refresh()

            # click and save file
            phone_entity_dict[cur_user][cur_distance].click_and_save(operation_full_name)

    # create database finish
    mlog.log_func(mlog.LOG, "Create database finish")
    # stop mitm and tshark
    for mitm in mitm_entity_list:
        mitm.stop_mitm_and_clear_iptables(f"{mitm.cur_packet_folder}/{mitm.cur_packet_name.split('.')[0]}.txt")
        mitm.stop_tshark()

    # stop frida hook, driver, appium server
    for distance_phone_dict in phone_entity_dict.values():
        for phone in distance_phone_dict.values():
            if phone:
                phone.stop_driver_and_appium_server()


if __name__ == "__main__":
    mlog.clear_log()

    # manual_learn_to_create_dataset("20230920183445_com.huawei.smarthome", "manual_dataset_1709359674")
    # learn_model_main("20230920183445_com.huawei.smarthome", "manual_dataset_1709359674")
    manual_create_database_for_double_wifi("20230920183445_com.huawei.smarthome")
