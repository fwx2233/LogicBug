"""
Learn APP's model
"""
import os
import json
import random
from collections import defaultdict
from appium import webdriver
from selenium.webdriver.common.by import By
from selenium.common import exceptions
import time
import socket
import subprocess, signal
import shutil

import format_tools
from log import mlog
import packet_parser
import get_ips
from config import device_appium_config
from my_check import check_if_frida_server_is_start


manually_flag = True
test_count = 1
# test_button_list = ['ADU1CWRD88:97:46:2C:9A:CE', 'RDU1CWRD88:97:46:2C:9A:CE']
# custom_order_dict = {}
test_button_list = ['ADU1CWRD88:97:46:2C:9A:CE', 'SDU1CWRU2D88:97:46:2C:9A:CE', 'SAU1CWRU2', 'USU1CWRU2',
                    'RDU1CWRD88:97:46:2C:9A:CE', 'DCU1']
custom_order_dict = {
    'ADU1CWRD88:97:46:2C:9A:CE': 0,
    'RDU1CWRD88:97:46:2C:9A:CE': len(test_button_list) - 1
}


def get_valuable_button(button_conf_file) -> dict:
    with open(button_conf_file, "r") as f:
        valuable_button_click_path = json.load(f)

    return valuable_button_click_path


def get_button_list(button_config_file):
    return list(get_valuable_button(button_config_file).keys())


def random_list(button_list: list) -> list:
    """
    use <button_list> to generate a random list
    :param button_list: [button1, button2]
    :return: random list generated by <button_list>
    """
    shuffled_list = button_list.copy()
    random.shuffle(shuffled_list)
    return shuffled_list


def get_custom_click_list(custom_order: dict, button_list: list) -> list:
    """
    Incorporate a custom order into a randomly generated list.
    :param custom_order: {button1: order, button2: order}
    :param button_list: [button1, button2]
    :return: custom click order -> list
    """
    shuffled_list = random_list(button_list)
    custom_order = format_tools.sort_dict_by_value(custom_order)

    for item, order in custom_order.items():
        if order > len(shuffled_list) or order < (0 - len(shuffled_list)):
            mlog.log_func(mlog.ERROR, f"Custom order <{item}--{order}> out of range, please check your custom order.")
            exit(3)
        index = shuffled_list.index(item)
        shuffled_list.pop(index)
    for item, order in custom_order.items():
        if order >= 0:
            shuffled_list.insert(order, item)

    return shuffled_list


def generate_random_click_order_with_count(valuable_button_list: list, each_least_count=3, each_large_count=10):
    return_list = []
    for cur in valuable_button_list:
        cur_count = random.randint(each_least_count, each_large_count)
        return_list.extend([cur for i in range(cur_count)])
    return random_list(return_list)


class LearnCls:
    def __init__(self, scan_folder_name, device_name):
        # paths
        self.ROOT_PATH = os.path.dirname(__file__)
        self.LOG_FOLDER_PATH = self.ROOT_PATH + "/../log/"
        self.PACKET_ROOT_PATH = self.ROOT_PATH + "/packets/"
        self.CONF_FOLDER_PATH = self.ROOT_PATH + "/../config/"
        self.SCRIPTS_FOLDER = self.ROOT_PATH + "/../scripts/"
        self.LEARNLIB_FOLDER = self.ROOT_PATH + "/learnlib_module/"
        self.ACT_TG_FILE = self.ROOT_PATH + "/../analyse_app/temp_scan_result/act_tg_" + scan_folder_name + ".json"
        self.ADD_TG_FILE = self.ROOT_PATH + "/../analyse_app/temp_scan_result/additional_tg_" + scan_folder_name + ".json"
        self.VALUABLE_BUTTON_FILE = self.CONF_FOLDER_PATH + "valuable_button.json"
        # self.APPIUM_PATH = "/home/ubuntu1604/.nvm/versions/node/v12.22.12/bin/appium"
        self.APPIUM_PATH = device_appium_config.appium_path

        # get config of device
        self.DEVICE_CONFIG_DICT = device_appium_config.get_device_config_by_name(device_name)
        if not self.DEVICE_CONFIG_DICT:
            mlog.log_func(mlog.ERROR, "Do not have device_name: " + device_name + ". Please check your input.")
            print("Device_name list: ", device_appium_config.get_device_list())
            exit(10)

        self.APK_NAME = self.DEVICE_CONFIG_DICT["appPackage"]
        self.APPIUM_IP = self.DEVICE_CONFIG_DICT["additionalMess"]["appium_ip"]
        self.APPIUM_PORT = self.DEVICE_CONFIG_DICT["additionalMess"]["port"]
        self.HOME_PAGE_ACT = self.DEVICE_CONFIG_DICT["additionalMess"]["homePage"]
        self.WIRELESS_CARD = self.DEVICE_CONFIG_DICT["additionalMess"]["wirelessCard"]
        self.APP_ACTIVITY = self.DEVICE_CONFIG_DICT["appActivity"]

        # remove additional message
        del self.DEVICE_CONFIG_DICT["additionalMess"]

        # modify wireless card message in script
        self.modify_mitm_script()
        self.modify_frida_script()

        # start appium for listen
        mlog.log_func(mlog.LOG, "Start appium service....")
        self.start_appium_server(self.APPIUM_PATH)
        time.sleep(3)

        mlog.log_func(mlog.LOG, "Start frida to ban the SSL Pinning")
        self.start_frida_hook()
        time.sleep(3)

        # communication information
        self.LOCAL_IP = ""
        self.LOCAL_PORT = 7009
        self.SERVER_IP = "127.0.0.1"
        self.SERVER_PORT = 9999
        self.SOCKET = ""

        # test flag and other info
        self.update_act_flag = False
        self.admin_password = "admin"
        self.cur_packet_name = ""
        self.cur_packet_path = ""

    def modify_mitm_script(self):
        # modify script
        lines = []
        with open(self.SCRIPTS_FOLDER + "launch_mitm.bash", "r") as f:
            for line in f.readlines():
                lines.append(line)
        lines[1] = 'WIRELESS_CARD="' + self.WIRELESS_CARD + '"\n'
        lines[2] = 'KEY_LOG_FILE="' + self.PACKET_ROOT_PATH + 'sslkeylogfile.txt"\n'
        with open(self.SCRIPTS_FOLDER + "launch_mitm.bash", "w") as f:
            for line in lines:
                f.write(line)
        lines.clear()  # clear

    def modify_frida_script(self):
        lines = []
        lines.append("#!/bin/bash")
        lines.append('target_app="' + self.APK_NAME + '"\n')
        lines.append('select_device="' + self.DEVICE_CONFIG_DICT["udid"] + '"\n')
        lines.append('script_path="' + self.SCRIPTS_FOLDER + 'pinning_disable.js"\n')
        lines.append("frida -D $select_device -F $target_app -l $script_path")

        with open(self.SCRIPTS_FOLDER + "start_pinning_frida_script.bash", "w") as f:
            for line in lines:
                f.write(line)
        lines.clear()  # clear

    def start_tshark(self, pcapng_name):
        # admin_proc
        admin_proc = subprocess.Popen(["echo", self.admin_password], stdout=subprocess.PIPE)

        # start tshark
        self.cur_packet_name = pcapng_name + '_' + str(int(time.time())) + ".pcapng"
        mlog.log_func(mlog.LOG, "Start capturing, save in file: " + self.cur_packet_name)

        # create folder
        if not os.path.exists(self.PACKET_ROOT_PATH):
            os.mkdir(self.PACKET_ROOT_PATH)
        self.cur_packet_path = self.PACKET_ROOT_PATH + self.cur_packet_name

        with open(self.LOG_FOLDER_PATH + "tshark_log_file.txt", "w") as log_file:
            a = subprocess.Popen(["sudo", "-S", "tshark", "-i", self.WIRELESS_CARD, "-w", self.cur_packet_path],
                                 stdin=admin_proc.stdout, stdout=log_file)

        # kill mitm
        self.kill_mitm()

        # start mitm
        command = "sudo -S bash " + self.SCRIPTS_FOLDER + "launch_mitm.bash"
        with open(self.LOG_FOLDER_PATH + "mitm_log.txt", "w") as log:
            mitm_proc = subprocess.Popen(command.split(), stdin=admin_proc.stdout, stdout=log)

        admin_proc.kill()

    def stop_tshark(self, with_error=0):
        admin_proc = subprocess.Popen(["echo", self.admin_password], stdout=subprocess.PIPE)
        cur_packet_folder = self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[0] + "/"
        cur_packet_path = self.PACKET_ROOT_PATH + self.cur_packet_name
        # stop tshark and chmod
        self.kill_tshark()
        stop_proc = subprocess.Popen(["sudo", "-S", "chmod", "777", cur_packet_path],
                                     stdin=admin_proc.stdout)

        # kill mitm
        self.kill_mitm()

        # chmod sslkeyfile
        subprocess.check_call(["sudo", "-S", "chmod", "777", self.PACKET_ROOT_PATH + 'sslkeylogfile.txt'],
                              stdin=admin_proc.stdout)
        # rename sslkeyfile
        os.rename(self.PACKET_ROOT_PATH + 'sslkeylogfile.txt', self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[0] + ".txt")

        if not os.path.exists(cur_packet_folder):
            os.makedirs(cur_packet_folder)
        # move file to it's folder
        shutil.move(self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[0] + ".txt", cur_packet_folder)
        shutil.move(cur_packet_path, cur_packet_folder)

        admin_proc.kill()

    def kill_mitm(self):
        admin_proc = subprocess.Popen(["echo", self.admin_password], stdout=subprocess.PIPE)
        # get process id
        file_name = self.SCRIPTS_FOLDER + "1.txt"
        command = "sudo -S netstat -tunlp|grep 8080 > " + file_name
        # save_proc = subprocess.Popen(command.split(), stdin=admin_proc.stdout, stdout=subprocess.PIPE)
        os.system('echo %s | sudo -S %s' % (self.admin_password, command))

        # parse id and kill mitm process
        if os.path.exists(file_name):
            with open(file_name, "r") as f:
                lines = f.readlines()
                if lines:
                    process_id = lines[0].split()[-1].split("/")[0]
                    command = "sudo -S kill -9 " + process_id
                    # temp_proc = subprocess.Popen(command.split(), stdin=admin_proc.stdout)
                    os.system('echo %s | sudo -S %s' % (self.admin_password, command))
            os.remove(file_name)

        # clear iptables
        command = "sudo -S bash " + self.SCRIPTS_FOLDER + "clear_iptables.bash"
        os.system('echo %s | sudo -S %s' % (self.admin_password, command))

        admin_proc.kill()

    def kill_tshark(self):
        fine_name = self.SCRIPTS_FOLDER + "temp_tshark_ps"
        command = "ps -aux|grep tshark > " + fine_name
        os.system(command)
        with open(fine_name, "r") as f:
            lines = f.readlines()
        if len(lines) > 1:
            admin_proc = subprocess.Popen(["echo", self.admin_password], stdout=subprocess.PIPE)
            for lin in lines[:-2]:
                porc_id = lin.split()[1]
                command = "sudo -S kill -9 " + porc_id
                temp_proc = subprocess.Popen(command.split(), stdin=admin_proc.stdout)
            admin_proc.kill()
        os.remove(fine_name)

    def start_frida_hook(self):
        # start disable ssl pinning
        command = "bash " + self.SCRIPTS_FOLDER + "start_pinning_frida_script.bash"
        sslpin_process = subprocess.Popen(command.split(), stdout=subprocess.PIPE)

    def stop_frida_hook(self):
        fine_name = self.SCRIPTS_FOLDER + "temp_tshark_ps"
        command = "ps -aux|grep frida > " + fine_name
        os.system(command)
        with open(fine_name, "r") as f:
            lines = f.readlines()
        if len(lines) > 1:
            admin_proc = subprocess.Popen(["echo", self.admin_password], stdout=subprocess.PIPE)
            for lin in lines[:-1]:
                porc_id = lin.split()[1]
                command = "sudo -S kill -9 " + porc_id
                temp = subprocess.Popen(command.split(), stdin=admin_proc.stdout)
            admin_proc.kill()
        os.remove(fine_name)

    def start_appium_server(self, path_to_appium):
        path = "/".join(path_to_appium.split("/")[:-1]) + ":"
        os.environ['PATH'] = path + os.environ['PATH']
        command = f"{path_to_appium} -a 127.0.0.1 -p {self.APPIUM_PORT} --session-override"
        with open(self.LOG_FOLDER_PATH + "appium_log.txt", "w") as log_file:
            process = subprocess.Popen(command, stdout=log_file, stderr=subprocess.STDOUT, shell=True, preexec_fn=os.setsid)
        self.appium_process = process

    def stop_appium_server(self):
        try:
            self.appium_process.terminate()
            time.sleep(1)
            os.killpg(os.getpgid(self.appium_process.pid), signal.SIGTERM)
        except ProcessLookupError:
            pass

    def get_tg_dict(self) -> dict:
        result = {}

        with open(self.ACT_TG_FILE, "r") as f:
            result.update(json.load(f))
        with open(self.ADD_TG_FILE, "r") as f:
            result.update(json.load(f))

        return result

    def create_socket(self):
        mlog.log_func(mlog.LOG, "Start connecting to server...")
        self.SOCKET = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.SOCKET.bind((self.LOCAL_IP, self.LOCAL_PORT))
        self.SOCKET.connect((self.SERVER_IP, self.SERVER_PORT))
        mlog.log_func(mlog.LOG, "Connection build")

    def get_input_from_learner(self):
        if manually_flag:
            return test_button_list
        else:
            # communicate with the server
            message = self.SOCKET.recv(1024)
            message_type = message[0]
            context = message[1:].decode('utf-8')
            if message_type == 1:
                print("[LOG] Receive input: " + context)
                '''
                '''
                # Add the response to Reset, which needs to be deleted later
                if context == "Reset":
                    self.SOCKET.sendall(bytes([message_type]) + "Reset has received".encode('utf-8'))
                '''
                '''
            else:
                print("[ERROR] Don't receive input message")
            return context

    def parse_packet_and_get_response(self, packet_name) -> str:
        return packet_parser.get_new_op_class_for_response(packet_name)

    def response_to_learner(self, output):
        """
        Tell the learner the output of operation.
        :param output: result str from packet parsing
        """
        reply_message = bytes([1]) + output.encode('utf-8')
        self.SOCKET.sendall(reply_message)

    def dfs_search(self, act1, act2):
        """
        使用dfs算法看是否在Activity中存在从act1切换到act2的路径
        """

        def search_graph(graph, start, end):
            results = []
            generate_path(graph, [start], end, results)
            results.sort(key=lambda x: len(x))
            return results

        def generate_path(graph, path, end, results):
            state = path[-1]
            if state == end:
                results.append(path)
            else:
                for arc in graph[state]:
                    if arc not in path:
                        generate_path(graph, path + [arc], end, results)

        act_tg_dict = self.get_tg_dict()

        if act1 in act_tg_dict.keys():
            for nodes in act_tg_dict.keys():
                act_tg_dict[nodes] = list(act_tg_dict[nodes].keys())

            r = search_graph(act_tg_dict, act1, act2)

            if not r:
                return None
            else:
                return r
        else:
            return None

    def start_driver(self):
        """
        read config of device and start appium driver
        :return: device driver for auto click
        """
        mlog.log_func(mlog.LOG, "Get device config:")
        mlog.log_dict_func(mlog.LOG, self.DEVICE_CONFIG_DICT)

        driver = webdriver.Remote(self.APPIUM_IP, self.DEVICE_CONFIG_DICT)

        self.driver = driver

    def stop_driver(self):
        self.driver.quit()
        self.stop_appium_server()

    def back_to_home(self, val_but_dict):
        mlog.log_func(mlog.LOG, "Back to homepage")
        command = f"adb shell am start -n {self.APK_NAME}/{self.APP_ACTIVITY}"
        while self.APK_NAME + self.driver.current_activity != self.HOME_PAGE_ACT:
            os.system(command)
            time.sleep(0.5)

        # back to home page
        while not self.click_button("BackHome", val_but_dict):
            mlog.log_func(mlog.LOG, "Press back-system")
            self.driver.back()
            time.sleep(0.5)

    def click_and_save(self, ui_name, uip_dict, waiting_time=8):
        """
        Click the button
        :param ui_name: action name
        :param uip_dict: click path dictionary of button
        :param waiting_time:
        :return:
        """
        mlog.log_func(mlog.LOG, "Click task-----" + ui_name)
        start_time = time.time()
        if self.click_button(ui_name, uip_dict):
            time.sleep(waiting_time)
            end_time = time.time()
            action_log_file = self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[0] + "/" + ui_name + "/" + ui_name + '_' + str(int(start_time)) + ".txt"
            if not os.path.exists(self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[0] + "/" + ui_name + "/"):
                os.makedirs(self.PACKET_ROOT_PATH + self.cur_packet_name.split(".")[0] + "/" + ui_name + "/")
            with open(action_log_file, "w") as log:
                log.write(self.cur_packet_name)
                log.write('\n')
                log.write(str(start_time))
                log.write('\n')
                log.write(str(end_time))
            get_ips.get_and_save_ip_list_by_apk(self.APK_NAME)
            return True
        return False

    def click_button(self, ui_name, uip_dict):
        """
        Click the button
        :param ui_name: action name will be clicked
        :param uip_dict: click path dictionary of button
        """
        is_special_op = False
        if ui_name in uip_dict["Special"]:
            is_special_op = True
        elif ui_name not in uip_dict.keys():
            mlog.log_func(mlog.ERROR, f"UI <{ui_name}> which will be clicked is not in config/valuable_button.json")
            return False

        # get click path
        if not is_special_op:
            click_path_dict = uip_dict[ui_name]
        else:
            click_path_dict = uip_dict["Special"][ui_name]

        # click one by one
        for index in click_path_dict.keys():
            # waiting
            if "waiting_time" in click_path_dict[index].keys():
                time.sleep(click_path_dict[index]["waiting_time"])

            if "description" in click_path_dict[index].keys():
                mlog.log_func(mlog.LOG, index + "---" + click_path_dict[index]["description"], t_count=1)
            else:
                mlog.log_func(mlog.LOG, index + "---" + ui_name + ": " + click_path_dict[index], t_count=1)

            # get location and click
            if "xpath" in click_path_dict[index].keys():
                cur_ui_xpath = click_path_dict[index]["xpath"]
                act_before = click_path_dict[index]["act_before"]
                act_after = click_path_dict[index]["act_after"]

                # if exist
                try:
                    # click
                    target = self.driver.find_element(By.XPATH, cur_ui_xpath)
                    if self.update_act_flag:
                        click_path_dict[index]["act_before"] = self.driver.current_activity
                    target.click()
                    if self.update_act_flag:
                        click_path_dict[index]["act_after"] = self.driver.current_activity
                except exceptions.NoSuchElementException:
                    # retry for 3 times
                    if_find_flag = False
                    for temp_index in range(3):
                        time.sleep(2)
                        try:
                            self.driver.find_element(By.XPATH, cur_ui_xpath).click()
                            if_find_flag = True
                            break
                        except exceptions.NoSuchElementException:
                            pass
                    if not if_find_flag:
                        mlog.log_func(mlog.LOG, "can not find component when --- " + click_path_dict[index]["description"])
                        return False

            # find element by resource id
            elif "resource_id" in click_path_dict[index].keys():
                cur_ui_id = click_path_dict[index]["resource_id"]
                id_index = click_path_dict[index]["rec_index"]
                act_before = click_path_dict[index]["act_before"]
                act_after = click_path_dict[index]["act_after"]

                # click with resource_id
                try:
                    target = self.driver.find_element(By.ID, cur_ui_id)
                    if self.update_act_flag:
                        click_path_dict[index]["act_before"] = self.driver.current_activity
                    target.click()
                    if self.update_act_flag:
                        click_path_dict[index]["act_after"] = self.driver.current_activity
                except exceptions.NoSuchElementException:
                    # retry for 3 times
                    if_find_flag = False
                    for temp_index in range(3):
                        time.sleep(2)
                        try:
                            self.driver.find_element(By.ID, cur_ui_id).click()
                            if_find_flag = True
                            break
                        except exceptions.NoSuchElementException:
                            pass
                    if not if_find_flag:
                        mlog.log_func(mlog.LOG, "can not find component when --- " + click_path_dict[index]["description"])
                        return False
            elif "posi_x" in click_path_dict[index].keys() and "posi_y" in click_path_dict[index].keys():
                self.driver.tap([(click_path_dict[index]["posi_x"], click_path_dict[index]["posi_y"])])

            # get current activity and check
            time.sleep(0.5)  # wait for activity
            cur_activity = self.driver.current_activity

        return True

    def randomly_create_database(self, valuable_button_list, uip_dict, mean_size=8):
        def check_if_enough():
            total_count = 0
            count_dict = defaultdict(int)
            for op_name in valuable_button_list:
                if op_name in os.listdir(self.cur_packet_path):
                    op_folder = self.cur_packet_path + op_name + "/"
                    count_dict[op_name] += len([x for x in os.listdir(op_folder) if op_name in x and x.split(".")[-1] == "txt"])
                    total_count += count_dict[op_name]
                else:
                    count_dict[op_name] += 0
            if 0 in list(count_dict.values()) or total_count < len(valuable_button_list) * mean_size:
                return False
            return True

        # round 1
        ori_click_order = generate_random_click_order_with_count(valuable_button_list)
        for op in ori_click_order:
            self.back_to_home(uip_dict)
            self.click_and_save(op, uip_dict)

        while not check_if_enough():
            ori_click_order = generate_random_click_order_with_count(valuable_button_list)
            for op in ori_click_order:
                self.back_to_home(uip_dict)
                self.click_and_save(op, uip_dict)

    def customized_create_database(self, custom_list, uip_dict):
        for op in custom_list:
            self.back_to_home(uip_dict)
            self.click_and_save(op, uip_dict)

    def load_alphabet(self, ui_list):
        """
        Send a reply to learner to tell the scan results.
        :param ui_list: valuable UI list
        :param server_socket: server socket to send message
        :return: response from Learner
        """
        # print log
        mlog.log_func(mlog.LOG, "send input_bat to learner...")
        print("input_bat: ", ui_list)

        # communicate with the server
        message = self.SOCKET.recv(1024)
        message_type = message[0]
        context = message[1:].decode('utf-8')
        if message_type == 0 and context == "alphabet":
            mlog.log_func(mlog.LOG, "Receive alphabet send request")

            # Send reply message
            reply_context = "Succeed!"
            reply_message = bytes([message_type]) + reply_context.encode('utf-8')
            self.SOCKET.sendall(reply_message)
            mlog.log_func(mlog.LOG, "Send reply message")
        else:
            mlog.log_func(mlog.ERROR, "Don't receive alphabet send request")

        # create file for alphabet
        alphabet_file = self.LEARNLIB_FOLDER + "src/main/resources/input_bat"
        with open(alphabet_file, "w") as f:
            for item in ui_list:
                if item != ui_list[-1]:
                    f.write(item + "\n")
                else:
                    f.write(item)
        mlog.log_func(mlog.LOG, "Create the alphabet file input_bat")

        self.get_input_from_learner()
        self.response_to_learner(self.get_input_from_learner() + "_suc")


def auto_learn_to_create_dataset(scan_result_name):
    # create an entity of learn
    learn_entity = LearnCls(scan_result_name, "nexus")
    # get val_buttons
    val_but_dict = get_valuable_button(learn_entity.VALUABLE_BUTTON_FILE)
    val_but_list = list(val_but_dict.keys())
    val_but_list.remove("Special")
    val_but_list.remove("add_scene")

    # start app and get driver
    learn_entity.start_driver()

    learn_entity.start_tshark("random_click_dataset")

    # click and capture
    learn_entity.randomly_create_database(val_but_list, val_but_dict)

    mlog.log_func(mlog.LOG, "Stop capture.")
    # stop packet capture, close android driver
    learn_entity.stop_tshark()
    learn_entity.stop_frida_hook()
    learn_entity.stop_driver()


def manual_learn_to_create_dataset(scan_result_name):
    mlog.log_func(mlog.LOG, "Manual test start")

    # create an entity of learn
    # learn_entity = LearnCls(scan_result_name, "nexus")
    learn_entity = LearnCls(scan_result_name, "pixel7")
    # get val_buttons
    val_but_dict = get_valuable_button(learn_entity.VALUABLE_BUTTON_FILE)
    val_but_list = list(val_but_dict.keys())
    val_but_list.remove("Special")
    val_but_list.remove("add_scene")

    # start app and get driver
    learn_entity.start_driver()
    learn_entity.start_tshark("manual_dataset")

    test_order_list = ["ADU1CWRD88:97:46:2C:9A:CE", "DCU1", "RDU1CWRD88:97:46:2C:9A:CE", "ADU1CWRD88:97:46:2C:9A:CE", "SAU1CWRU2", "DCU1", "DCU1", "RDU1CWRD88:97:46:2C:9A:CE", "USU1CWRU2"]
    mlog.log_list_func(mlog.LOG, test_order_list)

    for count in range(2):
        for cur_op_name in test_order_list:
            print("Current operation: ", cur_op_name)
            if cur_op_name == "SAU1CWRU2":
                print("\tSA, press agree/deny manually")
            learn_entity.back_to_home(val_but_dict)
            learn_entity.click_and_save(cur_op_name, val_but_dict)
            get_ips.get_and_save_ip_list_by_apk(learn_entity.APK_NAME)


    # click and capture
    # print("Input number to select input('q' to quit): ")
    # for i in range(len(val_but_list)):
    #     print("\t", i, val_but_list[i])
    # input_select = input("Enter current operation: ")
    # print("current input: ", input_select)
    # while input_select.lower() != "q":
    #     print("current input: ", input_select)
    #     if len(input_select) > 1 or len(input_select) == 0:
    #         print("[ERROR]\tPlease check and re-input('q' to quit)\t[ERROR]")
    #     elif int(input_select) < len(val_but_list):
    #         cur_op_name = val_but_list[int(input_select)]
    #         learn_entity.back_to_home(val_but_dict)
    #         learn_entity.click_and_save(cur_op_name, val_but_dict)
    #     else:
    #         print("[ERROR]\tPlease check and re-input('q' to quit)\t[ERROR]")
    #
    #     for i in range(len(val_but_list)):
    #         print("\t", i, val_but_list[i])
    #     input_select = input("Enter current operation: ")

    mlog.log_func(mlog.LOG, "Stop capture.")
    learn_entity.back_to_home(val_but_dict)
    # stop packet capture, close android driver
    learn_entity.stop_tshark()
    learn_entity.stop_frida_hook()
    learn_entity.stop_driver()


if __name__ == "__main__":
    mlog.clear_log()
    if not check_if_frida_server_is_start():
        print("[frida server] is not start")
        exit(10)
    # auto_learn_to_create_dataset("20230920183445_com.huawei.smarthome")
    manual_learn_to_create_dataset("20230920183445_com.huawei.smarthome")
